name: "Snippet CLI Commands Implementation (Phase 3.1)"
description: |

## Purpose

Implement CLI commands for managing snippets in the Janus project, enabling users to pull snippets from the database to files, push files as new snippet versions, list all snippets, and search for snippets by query. This establishes the foundation for CLI-based interaction with the Janus system.

## Core Principles

1. **Context is Complete but Focused**: Include ALL necessary documentation sections, specific examples, and discovered caveats by linking specific documents
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md
6. **Condense Repeated Code**: Refactor code that repeated

---

## Goal

Implement the following CLI commands for snippet management:
- `janus snippet pull <snippet-name>` - Pull a snippet from the database and save it to a file
- `janus snippet push <file-path> -m <message>` - Push a file as a new snippet version with a commit message
- `janus snippet list` - List all snippets in the database
- `janus snippet search "<query>"` - Search for snippets by name or description

## Why

- **Business value**: Enables developers to manage prompt snippets through familiar CLI workflows
- **Integration**: Integrates with existing database layer through GenericPersistence functions
- **Problems solved**: Provides easy access to snippet management without direct database interaction

## What

### User-visible behavior:
- CLI commands accessible via `janus snippet <command>`
- File-based workflow for snippet content management
- Clear, formatted output for list and search operations
- Proper error messages for missing snippets or files

### Technical requirements:
- Use @effect/cli for command structure
- Use GenericPersistence functions directly for all database operations
- Use Effect FileSystem for file operations
- Follow Effect-TS patterns throughout

### Success Criteria

- [ ] All four CLI commands functional and tested
- [ ] Integration with existing persistence layer verified
- [ ] File operations handle errors gracefully
- [ ] Help documentation auto-generated and accurate
- [ ] All tests passing with proper coverage

## All Needed Context

### Documentation & References

```yaml
# MUST READ - Include these specific sections in your context window

- url: https://effect.website/docs/guides/cli/introduction
  sections: ['Command Structure', 'Arguments and Options', 'Subcommands']
  why: Core patterns for building CLI applications with @effect/cli
  discovered_caveat: Commands must be composed hierarchically, not registered dynamically

- url: https://www.npmjs.com/package/@effect/cli
  sections: ['Basic Example', 'Command Composition']
  why: Shows real-world patterns for Effect CLI usage
  critical: |
    Use Command.make for creating commands
    Use Args for positional arguments
    Use Options for flags and valued options

- file: src/services/persistence/GenericPersistence.ts
  why: All snippet operations will use these generic functions directly
  critical: |
    DO NOT create new persistence functions or services
    Use GenericPersistence functions directly with 'Snippet' label
    Examples: GenericPersistence.findByName('Snippet', Snippet, name)
              GenericPersistence.createVersion('SnippetVersion', 'Snippet', ...)

- docfile: docs/llms/best-practices/generic-persistence-patterns.md
  include_sections: ['Usage Examples', 'Creating Specific Functions from Generics']
  why: Shows exactly how to use generic functions for Snippet operations
  critical: |
    Note section 2.1 states: "Do NOT create separate persistence services"
    Use generic functions directly in CLI commands

- docfile: docs/llms/effect/effect-compliance-checklist.md
  include_sections: ['Implementation Checklist', 'Testing Checklist']
  why: Ensures all Effect patterns are followed correctly

- url: https://effect.website/docs/guides/platform/file-system
  sections: ['Reading Files', 'Writing Files', 'Error Handling']
  why: Effect's FileSystem service for pull/push operations
  discovered_caveat: Always use Effect.gen with yield* for file operations

- file: examples/effect-official-examples/packages/create-effect-app/src/Cli.ts
  why: Real example of complex Effect CLI with subcommands and options
  gotcha: Shows pattern for Prompt usage and command composition
```

### Context Inclusion Guidelines

- Include COMPLETE sections when they contain implementation details
- Include MULTIPLE examples if they show different use cases
- Include ALL caveats and warnings discovered during research
- Skip sections about: history, philosophy, future plans, unrelated features
- When in doubt, include it - but be specific about WHY it's needed

### Current Codebase tree

```bash
src
├── domain
│   ├── index.ts
│   └── types
│       ├── branded.ts
│       ├── composition.ts
│       ├── config.ts
│       ├── database.ts
│       ├── errors.ts
│       ├── experiment.ts
│       ├── index.ts
│       ├── parameter.ts
│       ├── snippet.ts
│       ├── tag.ts
│       └── tests
│           ├── database-integration.test-layers.ts
│           └── index.ts
├── layers
│   ├── configuration
│   │   ├── Configuration.layer.ts
│   │   ├── Configuration.test-layers.ts
│   │   └── index.ts
│   ├── index.ts
│   └── neo4j
│       ├── index.ts
│       └── Neo4j.layer.ts
├── lib
│   └── test-utils.ts
└── services
    ├── config
    │   ├── index.ts
    │   └── utils.ts
    ├── neo4j
    │   ├── index.ts
    │   └── Neo4j.service.ts
    ├── persistence
    │   ├── GenericPersistence.test-layers.ts
    │   ├── GenericPersistence.ts
    │   └── index.ts
```

### Desired Codebase tree with files to be added

```bash
src
├── cli
│   ├── index.ts                    # Main CLI entry point with janus command
│   ├── commands
│   │   ├── index.ts               # Re-exports all commands
│   │   └── snippet
│   │       ├── index.ts           # Snippet subcommand with nested commands
│   │       ├── pull.ts            # Pull command implementation
│   │       ├── push.ts            # Push command implementation
│   │       ├── list.ts            # List command implementation
│   │       └── search.ts          # Search command implementation
│   └── utils
│       ├── console.ts             # Console output formatting utilities
│       └── file.ts                # File operation utilities
├── bin
│   └── janus.ts                   # Executable entry point
└── (existing structure remains unchanged)
```

### Domain Structure & Naming Conventions

- CLI commands follow verb-noun pattern (snippet pull, not pull-snippet)
- Each command is a separate module for clarity
- Utilities are shared across commands
- Test files follow *.test.ts pattern
- Layer files follow *.layer.ts pattern

### Known Gotchas & Library Quirks

```typescript
// CRITICAL: @effect/cli requires specific patterns
// Example: Commands must be created with Command.make, not classes
// Example: Arguments use Args.text, Options use Options.string
// Example: Subcommands are composed with Command.withSubcommands

// CRITICAL: Effect FileSystem requires platform layer
// Example: FileSystem operations need NodeFileSystem layer provided
// Example: All file operations return Effect, not Promise

// CRITICAL: Our codebase uses generic persistence
// Example: Don't create new snippet-specific queries
// Example: Use GenericPersistence.findByName('Snippet', Snippet, name)
```

## Implementation Blueprint

### Data models and structure

The core data models already exist, we'll use them:

```typescript
// From src/domain/types/snippet.ts
- Snippet: Core entity with id, name, description
- SnippetVersion: Version entity with content, commit_message
- SnippetId, SnippetVersionId: Branded ID types
- Slug: Branded type for names (lowercase-with-hyphens)

// Services we'll use:
- GenericPersistence: All database operations via generic functions
- FileSystem from @effect/platform-node: File operations
- No snippet-specific services - use generics directly
```

### List of tasks to be completed in order

```yaml
Task 1: Set up CLI infrastructure
CREATE src/bin/janus.ts:
  - Shebang line for Node.js execution
  - Import and run main CLI from src/cli/index.ts
  - Provide NodeContext layer

CREATE src/cli/index.ts:
  - Create main "janus" command
  - Import snippet subcommand
  - Use Command.withSubcommands to compose
  - Export run function with app metadata

Task 2: Create snippet subcommand structure
CREATE src/cli/commands/snippet/index.ts:
  - Create "snippet" command as parent
  - Import all subcommands (pull, push, list, search)
  - Compose with Command.withSubcommands
  - Export the composed command

CREATE src/cli/commands/index.ts:
  - Re-export snippet command for easy imports

Task 3: Implement utility functions
CREATE src/cli/utils/console.ts:
  - formatSnippet function for consistent output
  - formatSnippetList function for table display
  - Use Console.log from Effect for output

CREATE src/cli/utils/file.ts:
  - readFileContent function using FileSystem
  - writeFileContent function using FileSystem
  - snippetNameToFileName conversion utility
  - Handle file errors with proper Effect error types

Task 4: Implement pull command
CREATE src/cli/commands/snippet/pull.ts:
  - Use Args.text for snippet-name argument
  - Use GenericPersistence.mustFindByName('Snippet', 'snippet', Snippet, slug)
  - Use GenericPersistence.getLatestVersion for content
  - Write content to file using FileSystem
  - Handle NotFoundError with user-friendly message

Task 5: Implement push command
CREATE src/cli/commands/snippet/push.ts:
  - Use Args.file for file-path argument
  - Use Options.text for commit message (-m)
  - Read file content with FileSystem
  - Extract snippet name from filename
  - Use GenericPersistence.createNamedEntity and createVersion
  - Handle file not found and database errors

Task 6: Implement list command
CREATE src/cli/commands/snippet/list.ts:
  - No arguments needed
  - Use GenericPersistence.listAll('Snippet', Snippet)
  - Format output as table with name and description
  - Handle empty list case gracefully

Task 7: Implement search command
CREATE src/cli/commands/snippet/search.ts:
  - Use Args.text for search query
  - Implement search using GenericPersistence with custom query
  - Display results with highlighting if possible
  - Show "No results found" for empty results

Task 8: Update package.json
MODIFY package.json:
  - Add "bin" field pointing to dist/bin/janus.js
  - Update build script if needed
  - Ensure proper executable permissions

Task 9: Write comprehensive tests
CREATE src/cli/commands/snippet/pull.test.ts:
  - Test successful pull with mock data
  - Test snippet not found error
  - Test file write error handling

CREATE src/cli/commands/snippet/push.test.ts:
  - Test successful push with new version
  - Test file not found error
  - Test invalid snippet name handling

CREATE src/cli/commands/snippet/list.test.ts:
  - Test listing multiple snippets
  - Test empty list handling
  - Test formatting output

CREATE src/cli/commands/snippet/search.test.ts:
  - Test search with results
  - Test search with no results
  - Test search query validation
```

### Per task pseudocode

```typescript
// Task 1: Main CLI entry
// src/bin/janus.ts
#!/usr/bin/env node
import { NodeContext, NodeRuntime } from '@effect/platform-node'
import { Effect } from 'effect'
import { run } from '../cli'

run(process.argv).pipe(
  Effect.provide(NodeContext.layer),
  NodeRuntime.runMain({ disableErrorReporting: true })
)

// src/cli/index.ts
const mainCommand = Command.make('janus').pipe(
  Command.withSubcommands([snippetCommand])
)

export const run = Command.run(mainCommand, {
  name: 'Janus CLI',
  version: '0.0.1'
})

// Task 4: Pull command pattern
const pullCommand = Command.make('pull', {
  snippet: Args.text({ name: 'snippet-name' })
}, ({ snippet }) =>
  Effect.gen(function* () {
    // PATTERN: Decode slug first
    const slug = yield* Schema.decode(Slug)(snippet)
    
    // PATTERN: Use generic persistence functions
    const snippetEntity = yield* GenericPersistence.mustFindByName(
      'Snippet', 'snippet', Snippet, slug
    )
    const version = yield* GenericPersistence.getLatestVersion(
      'SnippetVersion', 'Snippet', SnippetVersion, snippetEntity.id
    )
    
    // PATTERN: File operations with FileSystem
    const filename = `${snippet}.snippet`
    yield* FileSystem.writeFileString(filename, version.content)
    
    yield* Console.log(`Pulled snippet '${snippet}' to ${filename}`)
  })
)

// Task 5: Push command pattern  
const pushCommand = Command.make('push', {
  file: Args.file({ name: 'file-path', exists: 'yes' }),
  message: Options.text('message').pipe(Options.withAlias('m'))
}, ({ file, message }) =>
  Effect.gen(function* () {
    // PATTERN: Read file content
    const content = yield* FileSystem.readFileString(file)
    
    // PATTERN: Extract name from filename
    const name = path.basename(file, '.snippet')
    const slug = yield* Schema.decode(Slug)(name)
    
    // PATTERN: Try to find existing, create if not found
    const existing = yield* GenericPersistence.findByName('Snippet', Snippet, slug)
    
    const snippetId = yield* Option.match(existing, {
      onNone: () => GenericPersistence.createNamedEntity(
        'Snippet', Snippet, { name: slug, description: `Snippet from ${file}` }
      ).pipe(Effect.map(s => s.id)),
      onSome: (s) => Effect.succeed(s.id)
    })
    
    // PATTERN: Create new version
    yield* GenericPersistence.createVersion(
      'SnippetVersion', 'Snippet', snippetId, SnippetVersion,
      { content, commit_message: message }
    )
    
    yield* Console.log(`Pushed ${file} as new version of '${name}'`)
  })
)
```

### Integration Points

```yaml
DATABASE:
  - Uses existing Neo4j connection through layers
  - No new migrations needed
  - All operations through GenericPersistence functions

CONFIG:
  - No new configuration needed
  - Uses existing Neo4j connection config

LAYERS:
  - Requires Neo4jClientLive layer
  - Requires NodeFileSystem layer for file operations
  - Compose in main CLI runner

PACKAGE:
  - add to: package.json
  - pattern: '"bin": { "janus": "./dist/bin/janus.js" }'
  - build output must include executable
```

## Validation Loop

### Level 1: Syntax & Type Checking

```bash
# Run these FIRST - fix any errors before proceeding
pnpm run build                    # TypeScript compilation
pnpm run lint                     # ESLint checking

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests

```typescript
// CREATE src/cli/test-layers/Cli.test-layers.ts - Test layers for CLI commands
import { Layer } from 'effect'
import { FileSystem } from '@effect/platform-node'
import { Neo4jTestWithGenericData, generateTestSnippet, generateTestSnippetVersionRaw } from '../../../services/persistence/GenericPersistence.test-layers'

// Test data for snippets
export const cliTestData = {
  snippets: [
    generateTestSnippet(
      '550e8400-e29b-41d4-a716-446655440001',
      'test-snippet',
      'A test snippet for CLI'
    ),
    generateTestSnippet(
      '550e8400-e29b-41d4-a716-446655440002',
      'another-snippet',
      'Another test snippet'
    )
  ],
  snippetVersions: [
    {
      version: {
        ...generateTestSnippetVersionRaw(
          '650e8400-e29b-41d4-a716-446655440001',
          'Test content for CLI',
          'Initial version',
          '2024-01-01T00:00:00.000Z'
        ),
      } as any,
      snippetId: '550e8400-e29b-41d4-a716-446655440001' as SnippetId,
    }
  ],
  // ... other test data as needed
}

// Create test layer for Neo4j with CLI test data
export const Neo4jTestLayerForCli = Neo4jTestWithGenericData(cliTestData)

// Mock FileSystem layer for testing
export const FileSystemTestLayer = Layer.succeed(FileSystem, {
  writeFileString: vi.fn().mockImplementation((path: string, content: string) => 
    Effect.succeed(undefined)
  ),
  readFileString: vi.fn().mockImplementation((path: string) => 
    path.includes('missing') 
      ? Effect.fail(new SystemError({ reason: 'NotFound', module: 'FileSystem', method: 'readFile' }))
      : Effect.succeed('Test file content')
  ),
  // ... other FileSystem methods as needed
})

// Test pattern for CLI commands
import { it } from '@effect/vitest'
import { Effect, Exit, Layer, pipe } from 'effect'
import { pullCommand } from '../commands/snippet/pull'
import { Neo4jTestLayerForCli, FileSystemTestLayer } from '../test-layers/Cli.test-layers'

it.effect('pull command should write snippet content to file', () =>
  Effect.gen(function* () {
    // Spy on file system operations
    const writeFileSpy = vi.spyOn(FileSystemTestLayer.value, 'writeFileString')
    
    // Run command with test layers
    yield* pipe(
      pullCommand.handler({ snippet: 'test-snippet' }),
      Effect.provide(Layer.mergeAll(Neo4jTestLayerForCli, FileSystemTestLayer))
    )
    
    // Verify file was written with correct content
    expect(writeFileSpy).toHaveBeenCalledWith(
      'test-snippet.snippet',
      'Test content for CLI'
    )
  })
)

it.effect('push command should handle file not found', () =>
  Effect.gen(function* () {
    const result = yield* pipe(
      pushCommand.handler({ 
        file: 'missing.snippet',
        message: 'Test message' 
      }),
      Effect.provide(Layer.mergeAll(Neo4jTestLayerForCli, FileSystemTestLayer)),
      Effect.either
    )
    
    expect(Exit.isFailure(result)).toBe(true)
    if (Exit.isFailure(result)) {
      expect(result.cause).toMatchObject({
        _tag: 'Fail',
        error: expect.objectContaining({
          reason: 'NotFound'
        })
      })
    }
  })
)

it.effect('list command should format output correctly', () =>
  Effect.gen(function* () {
    const consoleSpy = vi.spyOn(Console, 'log')
    
    yield* pipe(
      listCommand.handler({}),
      Effect.provide(Neo4jTestLayerForCli)
    )
    
    // Verify formatted output includes both test snippets
    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringContaining('test-snippet')
    )
    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringContaining('another-snippet')
    )
  })
)
```

```bash
# Run and iterate until passing:
pnpm test src/cli
# If failing: Read error, understand root cause, fix code, re-run
```

### Level 3: Integration Test

```bash
# Build the CLI
pnpm run build

# Make executable
chmod +x dist/bin/janus.js

# Test each command
./dist/bin/janus.js snippet list
# Expected: List of snippets or "No snippets found"

./dist/bin/janus.js snippet pull test-snippet
# Expected: Creates test-snippet.snippet file

./dist/bin/janus.js snippet push test-snippet.snippet -m "Updated content"
# Expected: Success message

./dist/bin/janus.js snippet search "test"
# Expected: Results containing "test"
```

## Final validation Checklist

- [ ] All tests pass: `pnpm test`
- [ ] No linting errors: `pnpm run lint`
- [ ] No type errors: `pnpm run build`
- [ ] Preflight passes: `pnpm run preflight`
- [ ] Manual test successful for all 4 commands
- [ ] Error cases handled with proper Effect error types
- [ ] Console output is clear and formatted
- [ ] Help documentation generated correctly
- [ ] All items from `docs/llms/effect/effect-compliance-checklist.md` completed

---

## Anti-Patterns to Avoid

- ❌ Don't create new persistence functions - use existing generic ones
- ❌ Don't use Promise/async-await - use Effect
- ❌ Don't handle errors with try/catch - use Effect error handling
- ❌ Don't concatenate file paths - use path utilities
- ❌ Don't forget to provide required layers
- ❌ Don't use console.log directly - use Effect's Console
- ❌ Don't mutate data - keep everything immutable
- ❌ Don't create entity-specific services when generics exist

## Confidence Score

**9/10** - This PRP provides comprehensive context including:
- Complete documentation references with specific sections
- Existing code patterns to follow
- Step-by-step implementation tasks
- Executable validation tests
- All necessary context for one-pass implementation

The only uncertainty is around potential edge cases in file handling that may emerge during implementation.