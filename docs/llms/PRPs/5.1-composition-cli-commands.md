name: "Composition CLI Commands"
description: |

## Purpose

Implement the CLI commands for managing compositions as specified in section 5.1 of the implementation todo. This enables users to create immutable composition versions that lock in specific snippet versions for reproducible prompt assembly.

## Core Principles

1. **Context is Complete but Focused**: Include ALL necessary documentation sections, specific examples, and discovered caveats by linking specific documents
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md
6. **Condense Repeated Code**: Refactor code that is repeated

---

## Goal

Implement the `janus composition` CLI commands to enable users to:
- Create new composition versions from existing compositions or tag groups
- List all available compositions

## Why

- Enables reproducible prompt assembly by locking in specific snippet versions
- Supports both explicit composition (from existing version) and dynamic composition (from tags)
- Critical for test execution where compositions define the prompt structure
- Provides version control for prompt recipes

## What

Implement two CLI subcommands under `janus composition`:
1. `create-version --from-composition <id> | --from-group <name> -m <message>` - Create immutable version
2. `list` - Show all compositions

### Success Criteria

- [ ] Both CLI commands implemented and functional
- [ ] Support for creating versions from compositions or tag groups
- [ ] Integration with existing persistence layers
- [ ] Proper error handling for missing entities
- [ ] Comprehensive tests for each command
- [ ] User documentation created

## All Needed Context

### Documentation & References

```yaml
- file: docs/design/cli-design.md
  why: Complete specification of composition CLI commands
  sections: ['janus composition']
  critical: |
    - create-version requires either --from-composition OR --from-group
    - --from-composition uses existing CompositionVersion ID
    - --from-group uses Tag slug to find all tagged snippets
    - Always requires -m message for version history
    - Creates immutable CompositionVersion with locked snippet versions

- file: src/domain/types/composition.ts
  why: Composition domain model
  critical: |
    - Composition: id, name (Slug), description
    - CompositionVersion: id, snippets[], createdAt, commit_message
    - CompositionSnippet: snippetVersionId, role, sequence
    - Role: 'system' | 'user_prompt' | 'model_response'

- file: src/domain/types/tag.ts
  why: Tag model for group-based composition
  critical: |
    - Tag has name (Slug) and description
    - Tags link to Snippets (not versions)

- file: src/services/persistence/GenericPersistence.ts
  why: Generic functions for persistence
  functions: |
    - createNamedEntity() for compositions
    - findByName() for finding by slug
    - mustFindByName() for required lookups
    - listAll() for listing compositions
    - Note: CompositionVersion doesn't fit generic pattern

- file: docs/design/implementation-todo.md
  why: Original specification
  sections: ['5.1: Composition Persistence Service']
  critical: |
    - Custom functions needed for composition versions
    - Complex relationships don't fit generic patterns

- file: examples/effect-official-examples/templates/monorepo/packages/cli/src/Cli.ts
  why: CLI patterns with Effect
  patterns: |
    - Options.text() for named options
    - Options.withAlias() for shortcuts
    - Mutually exclusive options handling

- file: src/cli/commands/snippet/index.ts
  why: Existing CLI pattern to follow

- file: docs/llms/effect/effect-compliance-checklist.md
  why: Effect-TS best practices

- file: CLAUDE.md
  why: Project guidelines
```

### Current Codebase tree

```bash
src/
├── domain/
│   └── types/
│       ├── composition.ts      # Composition schemas
│       ├── tag.ts              # Tag schema
│       ├── snippet.ts          # Snippet schemas
│       └── branded.ts          # All ID types
├── services/
│   ├── persistence/
│   │   └── GenericPersistence.ts
│   ├── snippet/
│   │   └── SnippetPersistence.ts
│   └── neo4j/
├── cli/
│   └── commands/
│       ├── snippet/            # Existing pattern
│       └── parameter/          # Existing pattern
```

### Desired Codebase tree with files to be added and responsibility of file

```bash
src/
├── cli/
│   └── commands/
│       └── composition/
│           ├── index.ts              # Main composition command
│           ├── create-version.ts     # Create version command
│           └── list.ts               # List compositions command
├── services/
│   ├── composition/
│   │   ├── CompositionPersistence.ts # Composition-specific persistence
│   │   └── index.ts                  # Exports
│   └── tag/
│       ├── TagPersistence.ts         # Tag persistence for group queries
│       └── index.ts                  # Exports
tests/
├── cli/
│   └── composition/
│       ├── create-version.test.ts    # Create version tests
│       └── list.test.ts              # List command tests
├── services/
│   ├── composition/
│   │   └── CompositionPersistence.test.ts
│   └── tag/
│       └── TagPersistence.test.ts
```

### Known Gotchas of our codebase & Library Quirks

```typescript
// CRITICAL: CompositionVersion has complex relationships
// Cannot use generic createVersion - needs custom implementation

// CRITICAL: --from-composition uses CompositionVersionId (not CompositionId)
// Must copy snippets array from source version

// CRITICAL: --from-group requires Tag lookup and Snippet queries
// Must find all snippets with tag, then get latest versions

// CRITICAL: CompositionSnippet array must be properly ordered
// Group by role, then by sequence within role

// CRITICAL: No automatic Composition creation
// Unlike Snippet push, we don't auto-create parent Composition
// User must explicitly create Composition first

// CRITICAL: DateTimeUtc stored as ISO string
// Handle createdAt properly in CompositionVersion

// CRITICAL: Mutually exclusive options
// --from-composition and --from-group cannot both be provided
```

## Implementation Blueprint

### Data models and structure

```typescript
// Composition persistence (mix of generic and custom)
export const createComposition = (name: Slug, description: string) =>
  createNamedEntity('Composition', Composition, { name, description });

export const findCompositionByName = (name: Slug) =>
  findByName('Composition', Composition, name);

export const mustGetCompositionByName = (name: Slug) =>
  mustFindByName('Composition', 'composition', Composition, name);

export const listCompositions = () =>
  listAll('Composition', Composition);

// Custom function for CompositionVersion (doesn't fit generic pattern)
export const createCompositionVersion = (
  from: { compositionVersionId: CompositionVersionId } | { tagName: Slug },
  message: string
): Effect<CompositionVersion, PersistenceError | NotFoundError> =>
  Effect.gen(function* () {
    const neo4j = yield* Neo4jService;
    
    // Get snippets based on source
    let snippets: CompositionSnippet[];
    let compositionId: CompositionId;
    
    if ('compositionVersionId' in from) {
      // Copy from existing version
      const sourceVersion = yield* getCompositionVersionById(from.compositionVersionId);
      compositionId = yield* getCompositionIdFromVersion(from.compositionVersionId);
      snippets = sourceVersion.snippets;
    } else {
      // Build from tag group
      const taggedSnippets = yield* getSnippetsByTag(from.tagName);
      if (taggedSnippets.length === 0) {
        return yield* Effect.fail(new NotFoundError({
          entityType: 'tag',
          slug: from.tagName
        }));
      }
      
      // Get latest version for each snippet
      snippets = yield* Effect.forEach(taggedSnippets, (snippet, index) =>
        Effect.gen(function* () {
          const version = yield* mustGetLatestSnippetVersion(snippet.id);
          return {
            snippetVersionId: version.id,
            role: 'user_prompt' as const, // Default role
            sequence: index
          };
        })
      );
      
      // Create or find composition by tag name
      const existing = yield* findCompositionByName(from.tagName);
      compositionId = yield* Option.match(existing, {
        onNone: () => createComposition(
          from.tagName,
          `Composition from tag: ${from.tagName}`
        ).pipe(Effect.map(c => c.id)),
        onSome: (c) => Effect.succeed(c.id)
      });
    }
    
    // Create new version
    const versionId = CompositionVersionId.make(generateUuid());
    const version: CompositionVersion = {
      id: versionId,
      snippets,
      createdAt: new Date(),
      commit_message: message
    };
    
    // Save to database
    yield* neo4j.runInTransaction((tx) =>
      Effect.gen(function* () {
        // Create version node
        yield* tx.run(
          cypher`CREATE (cv:CompositionVersion $props)`,
          { props: version }
        );
        
        // Link to composition
        yield* tx.run(
          cypher`
            MATCH (c:Composition {id: $compositionId})
            MATCH (cv:CompositionVersion {id: $versionId})
            CREATE (cv)-[:VERSION_OF]->(c)
          `,
          { compositionId, versionId }
        );
        
        // Link to snippet versions
        yield* Effect.forEach(snippets, (snippet, index) =>
          tx.run(
            cypher`
              MATCH (sv:SnippetVersion {id: $snippetVersionId})
              MATCH (cv:CompositionVersion {id: $versionId})
              CREATE (cv)-[:INCLUDES {role: $role, sequence: $sequence}]->(sv)
            `,
            {
              snippetVersionId: snippet.snippetVersionId,
              versionId,
              role: snippet.role,
              sequence: snippet.sequence
            }
          )
        );
      })
    );
    
    return version;
  });

// Tag persistence
export const findTagByName = (name: Slug) =>
  findByName('Tag', Tag, name);

export const getSnippetsByTag = (tagName: Slug) =>
  Effect.gen(function* () {
    const neo4j = yield* Neo4jService;
    const query = cypher`
      MATCH (t:Tag {name: $tagName})<-[:TAGGED_WITH]-(s:Snippet)
      RETURN s
      ORDER BY s.name
    `;
    const params = yield* queryParams({ tagName });
    const results = yield* neo4j.runQuery<{ s: unknown }>(query, params);
    
    return yield* Effect.forEach(results, (r) =>
      Schema.decodeUnknown(Snippet)(r.s)
    );
  });
```

### List of tasks to be completed to fulfill the PRP in the order they should be completed

```yaml
Task 1: Create Tag persistence service
CREATE src/services/tag/TagPersistence.ts:
  - Import generic persistence functions
  - Implement basic tag functions using generics
  - Implement getSnippetsByTag custom function
  - Export all functions

CREATE src/services/tag/index.ts:
  - Re-export functions

Task 2: Create Composition persistence service
CREATE src/services/composition/CompositionPersistence.ts:
  - Import generic functions and types
  - Implement basic composition CRUD using generics
  - Implement custom createCompositionVersion
  - Implement helper functions:
    - getCompositionVersionById
    - getCompositionIdFromVersion
    - getLatestCompositionVersion
  - Export all functions

CREATE src/services/composition/index.ts:
  - Re-export functions

Task 3: Write tests for persistence layers
CREATE src/services/tag/TagPersistence.test.ts:
  - Test finding tags by name
  - Test getting snippets by tag

CREATE src/services/composition/CompositionPersistence.test.ts:
  - Test creating compositions
  - Test creating versions from existing version
  - Test creating versions from tag group
  - Test listing compositions

Task 4: Implement create-version command
CREATE src/cli/commands/composition/create-version.ts:
  - Define Options for --from-composition and --from-group
  - Define Options for -m message
  - Validate mutually exclusive options
  - Handle both creation paths
  - Show success with version ID

Task 5: Implement list command
CREATE src/cli/commands/composition/list.ts:
  - No arguments needed
  - Call listCompositions
  - Format as table with name and description
  - Handle empty list

Task 6: Combine into main composition command
CREATE src/cli/commands/composition/index.ts:
  - Import subcommands
  - Create main command
  - Add subcommands
  - Export for CLI

Task 7: Add to main CLI
MODIFY src/cli/index.ts:
  - Import compositionCommand
  - Add to subcommands

Task 8: Write CLI tests
CREATE tests/cli/composition/create-version.test.ts:
  - Test from-composition path
  - Test from-group path
  - Test mutually exclusive validation
  - Test error cases

CREATE tests/cli/composition/list.test.ts:
  - Test listing compositions
  - Test empty list

Task 9: Create documentation
CREATE docs/cli/composition-commands.md:
  - Usage examples
  - Workflow explanations
  - Integration with test execution
```

### Per task pseudocode

```typescript
// Task 4: create-version.ts
const createVersionCommand = Command.make('create-version', {
  fromComposition: Options.text('from-composition').pipe(
    Options.optional,
    Options.withDescription('ID of existing composition version to copy')
  ),
  fromGroup: Options.text('from-group').pipe(
    Options.optional,
    Options.withDescription('Tag name to build composition from')
  ),
  message: Options.text('message').pipe(
    Options.withAlias('m'),
    Options.withDescription('Commit message for the version')
  )
}).pipe(
  Command.withDescription('Create a new immutable composition version'),
  Command.withHandler(({ fromComposition, fromGroup, message }) =>
    Effect.gen(function* () {
      // Validate mutually exclusive options
      if (Option.isNone(fromComposition) && Option.isNone(fromGroup)) {
        yield* Console.error(
          'Error: Must specify either --from-composition or --from-group'
        );
        return yield* Effect.fail('InvalidOptions');
      }
      
      if (Option.isSome(fromComposition) && Option.isSome(fromGroup)) {
        yield* Console.error(
          'Error: Cannot specify both --from-composition and --from-group'
        );
        return yield* Effect.fail('InvalidOptions');
      }
      
      // Create version based on source
      const version = yield* Option.match(fromComposition, {
        onSome: (compVersionId) => {
          // Validate and parse ID
          const id = yield* Schema.decode(CompositionVersionId)(compVersionId).pipe(
            Effect.mapError(() => 
              new Error(`Invalid composition version ID: ${compVersionId}`)
            )
          );
          
          return createCompositionVersion(
            { compositionVersionId: id },
            message
          );
        },
        onNone: () => {
          const tagName = Option.getOrThrow(fromGroup);
          const slug = yield* Schema.decode(Slug)(tagName).pipe(
            Effect.mapError(() => 
              new Error(`Invalid tag name: ${tagName}`)
            )
          );
          
          return createCompositionVersion(
            { tagName: slug },
            message
          );
        }
      }).pipe(
        Effect.flatten,
        Effect.catchTag('NotFoundError', (error) => {
          const source = Option.isSome(fromComposition) 
            ? `Composition version '${Option.getOrElse(fromComposition, () => '')}'`
            : `Tag '${Option.getOrElse(fromGroup, () => '')}'`;
          
          return Console.error(`${source} not found`).pipe(
            Effect.zipRight(Effect.fail(error))
          );
        })
      );
      
      yield* Console.log(
        `✓ Created composition version ${version.id}\n` +
        `  Snippets: ${version.snippets.length}\n` +
        `  Message: ${version.commit_message}`
      );
    })
  )
);

// Task 5: list.ts
const listCommand = Command.make('list').pipe(
  Command.withDescription('List all compositions'),
  Command.withHandler(() =>
    Effect.gen(function* () {
      const compositions = yield* listCompositions();
      
      if (compositions.length === 0) {
        yield* Console.log('No compositions found');
        return;
      }
      
      yield* Console.log('Compositions:');
      yield* Console.log('─'.repeat(60));
      
      yield* Effect.forEach(compositions, (comp) =>
        Console.log(`${comp.name.padEnd(25)} ${comp.description}`)
      );
    })
  )
);
```

### Integration Points

```yaml
IMPORTS:
  - from: @effect/cli
    items: [Command, Options]
  - from: ../../services/composition/CompositionPersistence
    items: [composition functions]
  - from: ../../services/tag/TagPersistence  
    items: [tag functions]
  - from: ../../services/snippet/SnippetPersistence
    items: [mustGetLatestSnippetVersion]
  - from: effect
    items: [Effect, Console, Option, Schema]
    
LAYERS:
  - Neo4jClientLive
  - ConfigLive
  
ERROR_HANDLING:
  - NotFoundError for missing entities
  - PersistenceError for database issues
  - Custom validation for mutually exclusive options
```

## Validation Loop

### Level 1: Syntax & Type Checking

```bash
# Run these FIRST
pnpm run build
pnpm run lint

# Expected: No errors
```

### Level 2: Unit Tests

```bash
# Test persistence layers
pnpm test src/services/tag/TagPersistence.test.ts
pnpm test src/services/composition/CompositionPersistence.test.ts

# Test CLI commands
pnpm test tests/cli/composition/create-version.test.ts
pnpm test tests/cli/composition/list.test.ts

# Expected: All pass
```

### Level 3: Integration Tests

```bash
# Manual testing
docker-compose up neo4j

# Create test data
node dist/cli/main.js snippet push examples/greeting.txt -m "Initial greeting"
node dist/cli/main.js snippet push examples/instruction.txt -m "Initial instruction"

# Create composition from scratch
node dist/cli/main.js composition create greeting-flow --description "Standard greeting workflow"

# Create versions
node dist/cli/main.js composition create-version --from-group greeting-snippets -m "Version from greeting tag"
node dist/cli/main.js composition list

# Get the version ID from output, then:
node dist/cli/main.js composition create-version --from-composition <version-id> -m "Copy of greeting v1"
```

### Level 4: Full Validation

```bash
pnpm run preflight

# Expected: All checks pass
```

## Final validation Checklist

- [ ] All tests pass: `pnpm test tests/cli/composition`
- [ ] No linting errors: `pnpm run lint`
- [ ] No type errors: `pnpm run build`
- [ ] Preflight passes: `pnpm run preflight`
- [ ] Manual testing of both creation paths works
- [ ] Mutually exclusive options properly validated
- [ ] Error messages are clear and helpful
- [ ] All items from `docs/llms/effect/effect-compliance-checklist.md` checked
- [ ] User documentation created

---

## Anti-Patterns to Avoid

- ❌ Don't use generic createVersion - CompositionVersion is too complex
- ❌ Don't allow both --from options together
- ❌ Don't auto-create Compositions (unlike Snippet push)
- ❌ Don't forget to order snippets by role and sequence
- ❌ Don't skip tag validation when using --from-group
- ❌ Don't use raw console.log
- ❌ Don't throw exceptions - use Effect error handling

## Confidence Score

I rate this PRP **7/10** for one-pass implementation success.

Strengths:
- Clear specifications from cli-design.md
- Existing patterns from snippet/parameter commands
- Generic persistence for basic operations
- Well-defined domain models

Challenges:
- Complex custom logic for CompositionVersion creation
- Two different creation paths with different logic
- Tag-based composition requires multiple queries
- Relationship management in Neo4j transactions
- Mutually exclusive option validation

The complexity of composition version creation and the two distinct paths make this more challenging than previous commands.