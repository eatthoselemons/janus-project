name: "Parameter CLI Commands"
description: |

## Purpose

Implement the CLI commands for managing parameters as specified in section 4.1 of the implementation todo. This enables users to create injectable parameters and manage their possible values with version control.

## Core Principles

1. **Context is Complete but Focused**: Include ALL necessary documentation sections, specific examples, and discovered caveats by linking specific documents
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md
6. **Condense Repeated Code**: Refactor code that is repeated

---

## Goal

Implement the `janus parameter` CLI commands to enable users to:
- Create new parameters with descriptions
- Add versioned option values to parameters
- List all available parameters
- List all options for a specific parameter

## Why

- Enables flexible configuration through injectable parameters
- Provides version control for parameter values
- Allows teams to manage shared configuration options
- Essential for the test execution phase where parameters are injected into compositions

## What

Implement four CLI subcommands under `janus parameter`:
1. `create <name> --description "<desc>"` - Create a new parameter
2. `add-option --parameter-name <name> <value> -m <message>` - Add a value option
3. `list` - Show all parameters
4. `list-options <parameter-name>` - Show all options for a parameter

### Success Criteria

- [ ] All four CLI commands implemented and functional
- [ ] Integration with generic persistence functions
- [ ] Proper error handling for duplicate names and missing parameters
- [ ] Comprehensive tests for each command
- [ ] User documentation created

## All Needed Context

### Documentation & References

```yaml
- file: docs/design/cli-design.md
  why: Complete specification of parameter CLI commands
  sections: ['janus parameter']
  critical: |
    - parameter create requires name and description
    - add-option requires parameter name, value, and commit message
    - list shows all parameters
    - list-options shows all values for a specific parameter

- file: src/domain/types/parameter.ts
  why: Parameter and ParameterOption schemas
  critical: |
    - Parameter: id, name (Slug), description
    - ParameterOption: id, value, createdAt, commit_message
    - ParameterOption is versioned like SnippetVersion

- file: src/services/persistence/GenericPersistence.ts
  why: Generic functions to use for implementation
  functions: |
    - createNamedEntity() for creating parameters
    - findByName() for checking existence
    - mustFindByName() for required lookups
    - listAll() for listing parameters
    - createVersion() for creating parameter options
    - getLatestVersion() for getting latest option

- file: docs/llms/best-practices/generic-persistence-patterns.md
  why: Patterns for using generic persistence
  sections: ['Named Entity Pattern', 'Versioned Entity Pattern']
  critical: |
    - Parameters follow named entity pattern
    - ParameterOptions follow versioned entity pattern
    - Use generic functions to avoid duplication

- file: examples/effect-official-examples/templates/monorepo/packages/cli/src/Cli.ts
  why: CLI patterns with Effect
  patterns: |
    - Command.make() for commands
    - Args.text() for positional arguments
    - Options.text() with Options.withDescription()
    - Command.withSubcommands() for nesting

- file: src/cli/commands/snippet/index.ts
  why: Existing CLI implementation pattern to follow
  sections: ['Command structure', 'Error handling']

- file: docs/llms/effect/effect-compliance-checklist.md
  why: Effect-TS best practices
  sections: ['Error Handling', 'Service Design']

- file: CLAUDE.md
  why: Project guidelines
  sections: ['Code Style & Conventions']
```

### Current Codebase tree

```bash
src/
├── domain/
│   └── types/
│       ├── parameter.ts        # Parameter, ParameterOption schemas
│       ├── branded.ts          # ParameterId, ParameterOptionId, Slug
│       └── errors.ts           # Error types
├── services/
│   └── persistence/
│       ├── GenericPersistence.ts    # Generic functions to use
│       └── index.ts
├── cli/
│   ├── commands/
│   │   └── snippet/            # Existing CLI pattern to follow
│   └── index.ts
```

### Desired Codebase tree with files to be added and responsibility of file

```bash
src/
├── cli/
│   └── commands/
│       └── parameter/
│           ├── index.ts              # Main parameter command with subcommands
│           ├── create.ts             # Create parameter command
│           ├── add-option.ts         # Add option command
│           ├── list.ts               # List parameters command
│           └── list-options.ts       # List options command
├── services/
│   └── parameter/
│       ├── ParameterPersistence.ts   # Parameter-specific persistence using generics
│       └── index.ts                  # Exports
tests/
├── cli/
│   └── parameter/
│       ├── create.test.ts            # Create command tests
│       ├── add-option.test.ts        # Add option tests
│       ├── list.test.ts              # List command tests
│       └── list-options.test.ts      # List options tests
├── services/
│   └── parameter/
│       └── ParameterPersistence.test.ts  # Persistence layer tests
```

### Known Gotchas of our codebase & Library Quirks

```typescript
// CRITICAL: ParameterOption follows versioned entity pattern
// Similar to SnippetVersion but with 'value' instead of 'content'

// CRITICAL: Parameter names must be valid Slugs (lowercase-with-hyphens)
// Validate with Schema.decodeSync(Slug) before creating

// CRITICAL: ParameterOption doesn't have PREVIOUS_VERSION relationship
// Unlike SnippetVersion, we don't track version chains for options

// CRITICAL: DateTimeUtc stored as ISO string in Neo4j
// createdAt field needs proper handling

// CRITICAL: Use generic persistence functions
// Don't duplicate logic - compose from GenericPersistence

// CRITICAL: Follow existing CLI patterns from snippet commands
// Consistent error messages and console output
```

## Implementation Blueprint

### Data models and structure

```typescript
// Parameter persistence functions composed from generics
export const createParameter = (name: Slug, description: string) =>
  createNamedEntity('Parameter', Parameter, { name, description });

export const findParameterByName = (name: Slug) =>
  findByName('Parameter', Parameter, name);

export const mustGetParameterByName = (name: Slug) =>
  mustFindByName('Parameter', 'parameter', Parameter, name);

export const listParameters = () =>
  listAll('Parameter', Parameter);

// ParameterOption functions
export const createParameterOption = (
  parameterId: ParameterId,
  value: string,
  commit_message: string
) =>
  createVersion(
    'ParameterOption',
    'Parameter',
    parameterId,
    ParameterOption,
    { value, commit_message }
  );

// Custom function for listing all options (not just latest)
export const listParameterOptions = (parameterId: ParameterId) =>
  Effect.gen(function* () {
    const neo4j = yield* Neo4jService;
    const query = cypher`
      MATCH (p:Parameter {id: $parameterId})<-[:VERSION_OF]-(po:ParameterOption)
      RETURN po
      ORDER BY po.createdAt DESC
    `;
    const params = yield* queryParams({ parameterId });
    const results = yield* neo4j.runQuery<{ po: unknown }>(query, params);
    
    return yield* Effect.forEach(results, (r) =>
      Schema.decodeUnknown(ParameterOption)(r.po)
    );
  });
```

### List of tasks to be completed to fulfill the PRP in the order they should be completed

```yaml
Task 1: Create Parameter persistence service
CREATE src/services/parameter/ParameterPersistence.ts:
  - Import generic persistence functions
  - Implement parameter CRUD using generics:
    - createParameter using createNamedEntity
    - findParameterByName using findByName
    - mustGetParameterByName using mustFindByName
    - listParameters using listAll
  - Implement option functions:
    - createParameterOption using createVersion
    - listParameterOptions (custom - lists all versions)
  - Export all functions

CREATE src/services/parameter/index.ts:
  - Re-export all functions from ParameterPersistence

Task 2: Write tests for Parameter persistence
CREATE src/services/parameter/ParameterPersistence.test.ts:
  - Test parameter creation with duplicate name handling
  - Test finding parameters by name
  - Test listing all parameters
  - Test creating parameter options
  - Test listing all options for a parameter
  - Use test layers for Neo4j

Task 3: Implement create command
CREATE src/cli/commands/parameter/create.ts:
  - Define Args.text for name
  - Define Options.text for description
  - Validate name as Slug
  - Call createParameter
  - Handle duplicate name errors
  - Show success message

Task 4: Implement add-option command
CREATE src/cli/commands/parameter/add-option.ts:
  - Define Options.text for parameter-name
  - Define Args.text for value
  - Define Options.text for message (-m)
  - Find parameter by name (handle not found)
  - Create parameter option
  - Show success message

Task 5: Implement list command
CREATE src/cli/commands/parameter/list.ts:
  - No arguments needed
  - Call listParameters
  - Format as table showing name and description
  - Handle empty list case

Task 6: Implement list-options command
CREATE src/cli/commands/parameter/list-options.ts:
  - Define Args.text for parameter-name
  - Find parameter by name (handle not found)
  - Call listParameterOptions
  - Format showing value, date, and commit message
  - Handle no options case

Task 7: Combine into main parameter command
CREATE src/cli/commands/parameter/index.ts:
  - Import all subcommands
  - Create main command with Command.make('parameter')
  - Add subcommands with Command.withSubcommands
  - Export for CLI integration

Task 8: Add parameter command to main CLI
MODIFY src/cli/index.ts:
  - Import parameterCommand
  - Add to main CLI subcommands array

Task 9: Write comprehensive CLI tests
CREATE tests/cli/parameter/*.test.ts:
  - Test each command success case
  - Test error cases (not found, duplicates)
  - Test validation (invalid slugs)
  - Mock persistence layer

Task 10: Create user documentation
CREATE docs/cli/parameter-commands.md:
  - Usage examples for each command
  - Common workflows
  - Parameter injection explanation
```

### Per task pseudocode

```typescript
// Task 1: ParameterPersistence.ts
import { Effect, Option } from 'effect';
import { 
  createNamedEntity, 
  findByName, 
  mustFindByName, 
  listAll,
  createVersion 
} from '../persistence/GenericPersistence';
import { Parameter, ParameterOption } from '../../domain/types/parameter';
import { ParameterId, Slug } from '../../domain/types/branded';
import { Neo4jService } from '../neo4j';
import { cypher, queryParams } from '../../domain/types/database';
import { Schema } from 'effect';

export const createParameter = (name: Slug, description: string) =>
  createNamedEntity('Parameter', Parameter, { name, description });

export const findParameterByName = (name: Slug) =>
  findByName('Parameter', Parameter, name);

export const mustGetParameterByName = (name: Slug) =>
  mustFindByName('Parameter', 'parameter', Parameter, name);

export const listParameters = () =>
  listAll('Parameter', Parameter);

export const createParameterOption = (
  parameterId: ParameterId,
  value: string,
  commit_message: string
) =>
  createVersion(
    'ParameterOption',
    'Parameter',
    parameterId,
    ParameterOption,
    { value, commit_message }
  );

// Task 3: create.ts
const createCommand = Command.make('create', {
  name: Args.text({ name: 'name' }).pipe(
    Args.withDescription('Parameter name (lowercase-with-hyphens)')
  ),
  description: Options.text('description').pipe(
    Options.withDescription('Parameter description')
  )
}).pipe(
  Command.withDescription('Create a new parameter'),
  Command.withHandler(({ name, description }) =>
    Effect.gen(function* () {
      // Validate slug
      const slug = yield* Schema.decode(Slug)(name).pipe(
        Effect.mapError(() => 
          new Error(`Invalid parameter name '${name}'. Must be lowercase-with-hyphens`)
        )
      );
      
      const parameter = yield* createParameter(slug, description).pipe(
        Effect.catchTag('PersistenceError', (error) => {
          if (error.originalMessage.includes('already exists')) {
            return Console.error(`Parameter '${name}' already exists`).pipe(
              Effect.zipRight(Effect.fail(error))
            );
          }
          return Effect.fail(error);
        })
      );
      
      yield* Console.log(`✓ Created parameter '${parameter.name}'`);
    })
  )
);

// Task 4: add-option.ts
const addOptionCommand = Command.make('add-option', {
  parameterName: Options.text('parameter-name').pipe(
    Options.withDescription('Name of the parameter')
  ),
  value: Args.text({ name: 'value' }).pipe(
    Args.withDescription('Option value')
  ),
  message: Options.text('message').pipe(
    Options.withAlias('m'),
    Options.withDescription('Commit message')
  )
}).pipe(
  Command.withDescription('Add a value option to a parameter'),
  Command.withHandler(({ parameterName, value, message }) =>
    Effect.gen(function* () {
      const slug = yield* Schema.decode(Slug)(parameterName).pipe(
        Effect.mapError(() => 
          new Error(`Invalid parameter name '${parameterName}'`)
        )
      );
      
      const parameter = yield* mustGetParameterByName(slug).pipe(
        Effect.catchTag('NotFoundError', () =>
          Console.error(`Parameter '${parameterName}' not found`).pipe(
            Effect.zipRight(Effect.fail('NotFound'))
          )
        )
      );
      
      const option = yield* createParameterOption(
        parameter.id,
        value,
        message
      );
      
      yield* Console.log(
        `✓ Added option '${value}' to parameter '${parameterName}'`
      );
    })
  )
);
```

### Integration Points

```yaml
IMPORTS:
  - from: @effect/cli
    items: [Command, Args, Options]
  - from: ../../services/parameter/ParameterPersistence
    items: [all parameter functions]
  - from: effect
    items: [Effect, Console, Option, Schema]
    
LAYERS:
  - Neo4jClientLive (for database access)
  - ConfigLive (for configuration)
  
ERROR_HANDLING:
  - NotFoundError -> "Parameter not found" messages
  - PersistenceError -> Handle duplicates and database errors
  - Schema validation -> Invalid slug format messages
```

## Validation Loop

### Level 1: Syntax & Type Checking

```bash
# Run these FIRST - fix any errors before proceeding
pnpm run build                    # TypeScript compilation
pnpm run lint                     # ESLint checking

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests

```bash
# Test persistence layer
pnpm test src/services/parameter/ParameterPersistence.test.ts

# Test CLI commands
pnpm test tests/cli/parameter/create.test.ts
pnpm test tests/cli/parameter/add-option.test.ts
pnpm test tests/cli/parameter/list.test.ts
pnpm test tests/cli/parameter/list-options.test.ts

# Expected: All tests pass
# Common issues:
# - Mock Neo4j service not configured correctly
# - Date handling for createdAt field
# - Slug validation errors
```

### Level 3: Integration Tests

```bash
# Manual testing with test database
docker-compose up neo4j

# Test commands
node dist/cli/main.js parameter create urgency-level --description "Level of urgency for tasks"
node dist/cli/main.js parameter add-option --parameter-name urgency-level "must" -m "Highest priority"
node dist/cli/main.js parameter add-option --parameter-name urgency-level "should" -m "Medium priority"
node dist/cli/main.js parameter add-option --parameter-name urgency-level "may" -m "Low priority"
node dist/cli/main.js parameter list
node dist/cli/main.js parameter list-options urgency-level
```

### Level 4: Full Validation

```bash
# Run preflight check
pnpm run preflight

# Expected: All checks pass
```

## Final validation Checklist

- [ ] All tests pass: `pnpm test tests/cli/parameter`
- [ ] No linting errors: `pnpm run lint`
- [ ] No type errors: `pnpm run build`
- [ ] Preflight passes: `pnpm run preflight`
- [ ] Manual testing of all commands works
- [ ] Error messages are user-friendly
- [ ] All generic persistence functions used (no duplication)
- [ ] All items from `docs/llms/effect/effect-compliance-checklist.md` checked
- [ ] User documentation created

---

## Anti-Patterns to Avoid

- ❌ Don't duplicate persistence logic - use generic functions
- ❌ Don't skip Slug validation - parameters must have valid names
- ❌ Don't use raw console.log - use Effect's Console service
- ❌ Don't throw exceptions - use Effect.fail with proper error types
- ❌ Don't create custom persistence when generics work
- ❌ Don't forget to handle all error cases
- ❌ Don't use Model.Class (Neo4j uses Schema.Struct)

## Confidence Score

I rate this PRP **9/10** for one-pass implementation success.

Strengths:
- Clear specifications from cli-design.md
- Generic persistence functions ready to compose
- Simple domain model (Parameter and ParameterOption)
- Existing CLI patterns from snippet commands to follow
- Straightforward error handling

Minor challenges:
- Custom listParameterOptions function needs to be written
- Date handling for createdAt field in ParameterOption
- Ensuring consistent error messages across commands