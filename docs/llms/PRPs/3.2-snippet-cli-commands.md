name: "Snippet CLI Commands"
description: |

## Purpose

Implement the CLI commands for managing snippets as specified in section 3.2 of the implementation todo. This provides users with a Git-like workflow for creating and editing snippets locally while maintaining versioned history in the database.

## Core Principles

1. **Context is Complete but Focused**: Include ALL necessary documentation sections, specific examples, and discovered caveats by linking specific documents
2. **Validation Loops**: Provide executable tests/lints the AI can run and fix
3. **Information Dense**: Use keywords and patterns from the codebase
4. **Progressive Success**: Start simple, validate, then enhance
5. **Global rules**: Be sure to follow all rules in CLAUDE.md
6. **Condense Repeated Code**: Refactor code that is repeated

---

## Goal

Implement the `janus snippet` CLI commands to enable users to:
- Pull snippets from the database to local files
- Push local file changes back to the database with version control
- List all available snippets
- Search snippets by query string

## Why

- Enables developers to use their favorite text editors for snippet creation
- Provides familiar Git-like workflow for version control
- Makes snippet management intuitive and efficient
- Aligns with the MVP requirements for the Janus Project

## What

Implement four CLI subcommands under `janus snippet`:
1. `pull <snippet-name>` - Download latest version to local file
2. `push <file-path> -m <message>` - Upload changes with commit message
3. `list` - Show all available snippets
4. `search "<query>"` - Find snippets matching query

### Success Criteria

- [ ] All four CLI commands implemented and functional
- [ ] Local workspace directory (`janus_workspace/`) created automatically
- [ ] File operations handle errors gracefully
- [ ] Integration with existing SnippetPersistence service
- [ ] Comprehensive tests for each command
- [ ] User documentation created

## All Needed Context

### Documentation & References

```yaml
- file: docs/design/cli-design.md
  why: Complete specification of CLI commands and behavior
  sections: ['janus snippet', 'Design Philosophy']
  critical: |
    - pull creates file in janus_workspace/ directory
    - push uses filename to determine snippet slug
    - push checks hash to avoid unnecessary versions
    - search performs semantic vector search

- file: examples/effect-official-examples/templates/monorepo/packages/cli/src/Cli.ts
  why: Example of Effect CLI with subcommands
  patterns: |
    - Command.make() for creating commands
    - Args.text() for positional arguments
    - Options.text() for named options
    - Command.withSubcommands() for nesting
    - Command.withHandler() for implementation

- file: src/services/snippet/SnippetPersistence.ts
  why: Existing persistence layer to integrate with
  functions: |
    - createSnippet(name: Slug, description: string)
    - mustGetSnippetByName(name: Slug)
    - createSnippetVersion(snippetId, content, commitMessage)
    - mustGetLatestSnippetVersion(snippetId)
    - listSnippets()
    - searchSnippets(query: string)

- file: docs/llms/guides/effect-neo4j/05-actions-layer-services.md
  why: Patterns for integrating services with CLI
  sections: ['Service Architecture', 'Error Handling']

- url: https://effect.website/docs/platform/file-system/
  why: FileSystem module documentation for file operations
  critical: |
    - Use FileSystem service from @effect/platform
    - NodeFileSystem.layer provides implementation
    - Methods: readFileString, writeFileString, exists, mkdir

- file: docs/llms/effect/effect-compliance-checklist.md
  why: Ensure implementation follows Effect-TS patterns
  sections: ['Error Handling', 'Service Design', 'Testing']

- file: CLAUDE.md
  why: Project-specific guidelines
  sections: ['Code Style & Conventions', 'Development Best Practices']

- url: https://www.npmjs.com/package/@effect/vitest
  why: Testing patterns for Effect-TS with Vitest
```

### Current Codebase tree

```bash
src/
├── domain/
│   └── types/
│       ├── snippet.ts          # Snippet, SnippetVersion schemas
│       ├── branded.ts          # Slug, SnippetId types
│       └── errors.ts           # Error types
├── services/
│   └── snippet/
│       ├── SnippetPersistence.ts    # Persistence functions
│       └── index.ts                 # Exports
└── layers/
    └── neo4j/
        └── Neo4j.layer.ts      # Neo4j layer configuration
```

### Desired Codebase tree with files to be added and responsibility of file

```bash
src/
├── cli/
│   ├── commands/
│   │   └── snippet/
│   │       ├── index.ts              # Main snippet command with subcommands
│   │       ├── pull.ts               # Pull command implementation
│   │       ├── push.ts               # Push command implementation  
│   │       ├── list.ts               # List command implementation
│   │       ├── search.ts             # Search command implementation
│   │       └── common.ts             # Shared utilities (workspace path, etc)
│   ├── index.ts                      # Main CLI entry point
│   └── main.ts                       # CLI runner with layers
├── services/
│   └── snippet/
│       └── SnippetPersistence.ts     # Existing (no changes)
tests/
├── cli/
│   └── snippet/
│       ├── pull.test.ts              # Pull command tests
│       ├── push.test.ts              # Push command tests
│       ├── list.test.ts              # List command tests
│       └── search.test.ts            # Search command tests
```

### Known Gotchas of our codebase & Library Quirks

```typescript
// CRITICAL: @effect/cli uses functional composition, not classes
// Commands are built with Command.make() and composed with pipe()

// CRITICAL: FileSystem operations return Effect, not Promise
// Must use Effect.gen and yield* for async operations

// CRITICAL: Slug validation - must be lowercase-with-hyphens
// Extract slug from filename: "my-snippet.txt" -> "my-snippet"

// CRITICAL: Error handling - map FileSystem errors to our error types
import { FileSystemError } from '../../domain/types/errors';

// CRITICAL: Workspace directory should be relative to current working directory
// Use process.cwd() + '/janus_workspace/'

// CRITICAL: Console output uses Effect's Console service, not console.log
import { Console } from 'effect';

// CRITICAL: Hash calculation for content comparison
// Use Node.js crypto.createHash('sha256')
```

## Implementation Blueprint

### Data models and structure

```typescript
// File path utilities
export const WORKSPACE_DIR = 'janus_workspace';
export const getWorkspacePath = () => Path.join(process.cwd(), WORKSPACE_DIR);
export const getSnippetFilePath = (slug: string) => 
  Path.join(getWorkspacePath(), `${slug}.txt`);

// Content hash for comparison
export const calculateHash = (content: string): string => {
  const hash = crypto.createHash('sha256');
  hash.update(content);
  return hash.digest('hex');
};
```

### List of tasks to be completed to fulfill the PRP in the order they should be completed

```yaml
Task 1: Create CLI structure and main entry point
CREATE src/cli/index.ts:
  - Define main CLI command with name and version
  - Import snippet command (to be created)
  - Set up Command.run with proper configuration

CREATE src/cli/main.ts:
  - Set up NodeRuntime with required layers
  - Include NodeFileSystem.layer and Neo4j layers
  - Handle process.argv

Task 2: Create common utilities for snippet commands
CREATE src/cli/commands/snippet/common.ts:
  - Define WORKSPACE_DIR constant
  - Implement getWorkspacePath() function
  - Implement getSnippetFilePath(slug) function
  - Implement calculateHash(content) function
  - Implement ensureWorkspaceExists() Effect

Task 3: Implement pull command
CREATE src/cli/commands/snippet/pull.ts:
  - Define Args.text for snippet-name
  - Implement handler that:
    - Gets snippet by name (handle NotFoundError)
    - Gets latest version
    - Ensures workspace directory exists
    - Writes content to file
    - Shows success message with file path

Task 4: Implement push command
CREATE src/cli/commands/snippet/push.ts:
  - Define Args.text for file-path
  - Define Options.text for message (-m, --message) 
  - Implement handler that:
    - Reads file content
    - Extracts slug from filename
    - Gets or creates snippet
    - Compares hash with latest version
    - Creates new version if different
    - Shows appropriate success/no-change message

Task 5: Implement list command
CREATE src/cli/commands/snippet/list.ts:
  - No arguments needed
  - Implement handler that:
    - Calls listSnippets()
    - Formats output as table or list
    - Shows name and description for each

Task 6: Implement search command
CREATE src/cli/commands/snippet/search.ts:
  - Define Args.text for query
  - Implement handler that:
    - Calls searchSnippets(query)
    - Formats results with match highlights
    - Shows "No results" if empty

Task 7: Combine subcommands into main snippet command
CREATE src/cli/commands/snippet/index.ts:
  - Import all subcommands
  - Create main snippet command
  - Use Command.withSubcommands()
  - Export for use in main CLI

Task 8: Write comprehensive tests
CREATE tests/cli/snippet/*.test.ts:
  - Test each command with success cases
  - Test error handling (file not found, network errors)
  - Test edge cases (empty files, special characters)
  - Mock FileSystem and SnippetPersistence services

Task 9: Create user documentation
CREATE docs/cli/snippet-commands.md:
  - Usage examples for each command
  - Common workflows
  - Error messages and solutions
```

### Per task pseudocode

```typescript
// Task 1: Main CLI structure
// src/cli/index.ts
import { Command } from '@effect/cli';
import { snippetCommand } from './commands/snippet';

export const cli = Command.make('janus', {
  // No direct args, uses subcommands
}).pipe(
  Command.withDescription('The Janus Project CLI'),
  Command.withSubcommands([snippetCommand])
);

// src/cli/main.ts
import { NodeContext, NodeRuntime } from '@effect/platform-node';
import { Command } from '@effect/cli';
import { cli } from './index';
import { MainLive } from '../layers';

const main = Command.run(cli, {
  name: 'Janus CLI',
  version: '0.0.1'
});

main(process.argv).pipe(
  Effect.provide(MainLive), // Includes all required layers
  NodeRuntime.runMain
);

// Task 2: Common utilities
// src/cli/commands/snippet/common.ts
import { FileSystem, Path } from '@effect/platform';
import { Effect } from 'effect';
import * as crypto from 'crypto';

export const WORKSPACE_DIR = 'janus_workspace';

export const getWorkspacePath = Effect.gen(function* () {
  const path = yield* Path.Path;
  return path.join(process.cwd(), WORKSPACE_DIR);
});

export const ensureWorkspaceExists = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;
  const path = yield* getWorkspacePath;
  
  const exists = yield* fs.exists(path);
  if (!exists) {
    yield* fs.makeDirectory(path, { recursive: true });
  }
});

// Task 3: Pull command
// src/cli/commands/snippet/pull.ts
const pullCommand = Command.make('pull', {
  snippetName: Args.text({ name: 'snippet-name' })
}).pipe(
  Command.withDescription('Download snippet to local file'),
  Command.withHandler(({ snippetName }) =>
    Effect.gen(function* () {
      const slug = Schema.decodeSync(Slug)(snippetName);
      
      // Get snippet and version
      const snippet = yield* mustGetSnippetByName(slug);
      const version = yield* mustGetLatestSnippetVersion(snippet.id);
      
      // Write to file
      yield* ensureWorkspaceExists;
      const filePath = yield* getSnippetFilePath(slug);
      yield* fs.writeFileString(filePath, version.content);
      
      yield* Console.log(`✓ Pulled ${slug} to ${filePath}`);
    }).pipe(
      Effect.catchTag('NotFoundError', (error) =>
        Console.error(`✗ Snippet '${snippetName}' not found`)
      )
    )
  )
);

// Task 4: Push command (complex logic)
const pushCommand = Command.make('push', {
  filePath: Args.text({ name: 'file-path' }),
  message: Options.text('message').pipe(
    Options.withAlias('m'),
    Options.withDescription('Commit message')
  )
}).pipe(
  Command.withHandler(({ filePath, message }) =>
    Effect.gen(function* () {
      // Read file
      const content = yield* fs.readFileString(filePath).pipe(
        Effect.mapError(() => new FileSystemError({
          operation: 'read',
          path: filePath,
          reason: 'File not found'
        }))
      );
      
      // Extract slug from filename
      const basename = path.basename(filePath, '.txt');
      const slug = Schema.decodeSync(Slug)(basename);
      
      // Get or create snippet
      const existingSnippet = yield* maybeGetSnippetByName(slug);
      const snippet = yield* Option.match(existingSnippet, {
        onNone: () => createSnippet(slug, `Snippet for ${slug}`),
        onSome: Effect.succeed
      });
      
      // Check if content changed
      const latestVersion = yield* maybeGetLatestSnippetVersion(snippet.id);
      const contentHash = calculateHash(content);
      
      const needsUpdate = Option.match(latestVersion, {
        onNone: () => true,
        onSome: (v) => calculateHash(v.content) !== contentHash
      });
      
      if (needsUpdate) {
        yield* createSnippetVersion(snippet.id, content, message);
        yield* Console.log(`✓ Pushed new version of ${slug}`);
      } else {
        yield* Console.log(`✓ No changes to push for ${slug}`);
      }
    })
  )
);
```

### Integration Points

```yaml
IMPORTS:
  - from: @effect/cli
    items: [Command, Args, Options]
  - from: @effect/platform
    items: [FileSystem, Path]  
  - from: @effect/platform-node
    items: [NodeContext, NodeRuntime, NodeFileSystem]
  - from: ../../services/snippet/SnippetPersistence
    items: [all snippet functions]
  - from: effect
    items: [Effect, Console, Option, Layer, pipe]
    
LAYERS:
  - NodeFileSystem.layer (for file operations)
  - Neo4jClientLive (for database access) 
  - ConfigLive (for configuration)
  
ERROR_HANDLING:
  - FileSystemError -> User-friendly file error messages
  - NotFoundError -> "Snippet not found" messages
  - PersistenceError -> Database connection errors
  - Slug validation errors -> "Invalid snippet name" messages
```

## Validation Loop

### Level 1: Syntax & Type Checking

```bash
# Run these FIRST - fix any errors before proceeding
pnpm run build                    # TypeScript compilation
pnpm run lint                     # ESLint checking

# Expected: No errors. If errors, READ the error and fix.
```

### Level 2: Unit Tests

```bash
# Test individual commands
pnpm test tests/cli/snippet/pull.test.ts
pnpm test tests/cli/snippet/push.test.ts
pnpm test tests/cli/snippet/list.test.ts
pnpm test tests/cli/snippet/search.test.ts

# Expected: All tests pass
# Common issues:
# - Mock services not properly configured
# - File paths not properly handled cross-platform
# - Error types not matching expectations
```

### Level 3: Integration Tests

```bash
# Test full CLI with test database
pnpm test tests/cli/snippet/integration.test.ts

# Manual testing (requires running Neo4j):
# Terminal 1: Start test database
docker-compose up neo4j

# Terminal 2: Run CLI commands
pnpm build
node dist/cli/main.js snippet list
node dist/cli/main.js snippet pull test-snippet
node dist/cli/main.js snippet push janus_workspace/test-snippet.txt -m "Updated content"
node dist/cli/main.js snippet search "test"
```

### Level 4: End-to-End Validation

```bash
# Full preflight check
pnpm run preflight

# Expected: All checks pass
```

## Final validation Checklist

- [ ] All tests pass: `pnpm test tests/cli/snippet`
- [ ] No linting errors: `pnpm run lint`
- [ ] No type errors: `pnpm run build`
- [ ] Preflight passes: `pnpm run preflight`
- [ ] Manual testing of all commands works
- [ ] Workspace directory created automatically
- [ ] Error messages are user-friendly
- [ ] All items from `docs/llms/effect/effect-compliance-checklist.md` checked
- [ ] User documentation created

---

## Anti-Patterns to Avoid

- ❌ Don't use console.log - use Effect's Console service
- ❌ Don't use fs.promises - use FileSystem service from Effect
- ❌ Don't throw exceptions - use Effect.fail with proper error types
- ❌ Don't use classes for commands - use functional composition
- ❌ Don't hardcode paths - use Path service for cross-platform compatibility
- ❌ Don't skip error handling - handle all failure cases gracefully
- ❌ Don't mutate state - use immutable patterns
- ❌ Don't use process.exit - let Effect handle the exit code

## Confidence Score

I rate this PRP **8/10** for one-pass implementation success.

Strengths:
- Clear specifications from cli-design.md
- Existing persistence layer ready to use
- Strong examples from Effect CLI templates
- Well-defined error handling patterns

Potential challenges:
- File system operations cross-platform compatibility
- Hash comparison logic for detecting changes
- Complex error handling for various failure modes
- Testing file operations requires careful mocking