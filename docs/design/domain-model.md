# `docs/domain-model.md`

## The Janus Project: Domain Model Specification

This document specifies the core data model for the Janus Project. The model is designed with the principles of functional programming and type-driven development in mind. It prioritizes immutability, explicit versioning, and a clear audit trail for all entities.

### Core Principles

- **Branded Types for IDs:** To ensure type safety at the application level, all entity IDs are represented by "branded" or "opaque" types. This prevents accidentally using a `SnippetId` where a `CompositionId` is expected.
- **Application-Managed UUIDs:** All entity IDs are string UUIDs generated by the application. This supports decentralized creation of entities without ID conflicts, which is essential for a collaborative tool.
- **The `Slug` Type:** All human-readable names that are used for lookups (e.g., snippet names, parameter names) are constrained to a `Slug` type. This type is a URL- and command-line-friendly string (e.g., `lowercase-with-hyphens`) and can only be created via a smart constructor that performs validation.

---

### Entity Definitions

#### 1. Unified Content Types

The system uses a unified content model where all prompt-building entities (formerly snippets, parameters, and compositions) are represented as nodes in a content tree.

**`ContentNode`**
The abstract container for any content element and all its versions. It serves as the universal building block.

```typescript
type ContentNodeId = string & { readonly __brand: 'ContentNodeId' };
type Slug = string & { readonly __brand: 'Slug' };

type ContentNode = {
  id: ContentNodeId;
  name: Slug;
  description: string;
};
```

**`ContentNodeVersion`**
An immutable snapshot of a content node at a specific point in time. Content is optional to support both leaf nodes (with content) and branch nodes (organizing other nodes).

```typescript
type ContentNodeVersionId = string & { readonly __brand: 'ContentNodeVersionId' };

type ContentNodeVersion = {
  id: ContentNodeVersionId;
  content?: string; // Optional - branches may not have content
  createdAt: Date;
  commitMessage: string; // A mandatory message explaining the change
};
```

#### 2. Test Cases

Test cases define conversation structures and role assignments, enabling flexible prompt assembly and A/B testing.

**`TestCase`**
Defines a specific conversation structure with message slots that reference content nodes.

```typescript
type TestCaseId = string & { readonly __brand: 'TestCaseId' };
type LLMModel = string & { readonly __brand: 'LLMModel' }; // Validated pattern

type TestCase = {
  id: TestCaseId;
  name: string;
  description: string;
  createdAt: Date;
  llmModel: LLMModel;
  messageSlots: MessageSlot[];
  parameters?: ParameterContext; // Optional parameter values
};
```

**`MessageSlot`**
Specifies criteria for selecting content to fill a specific role in the conversation.

```typescript
type ContentRole = 'system' | 'user' | 'assistant';

type MessageSlot = {
  role: ContentRole;
  tags?: Array<TagId | TagName>; // Filter by tags
  excludeNodes?: Array<ContentNodeId | Slug>; // Exclude specific nodes
  includeNodes?: Array<ContentNodeId | Slug>; // Include specific nodes
  sequence: number; // Order in conversation
};
```

#### 3. Supporting Types

**Edge Properties**
Relationships between content nodes carry operational semantics.

```typescript
type EdgeOperation = 'insert' | 'concatenate';

type IncludesEdgeProperties = {
  operation: EdgeOperation;
  key?: string; // For insert operations - the placeholder to replace
};
```

**Parameter Context**
Type-safe parameter handling for content processing.

```typescript
type ParameterKey = string & { readonly __brand: 'ParameterKey' };
type ParameterValue = string & { readonly __brand: 'ParameterValue' };
type ParameterContext = HashMap<ParameterKey, ParameterValue>;
```

#### 4. Tags

**`Tag`**
A simple label for organizing and querying content nodes.

```typescript
type TagId = string & { readonly __brand: 'TagId' };

type Tag = {
  id: TagId;
  name: Slug;
};
```

#### 5. Testing & Results

These entities store the configuration and output of an experiment.

**`TestRun`**
The parent container for a single execution of a test suite.

```typescript
type TestRunId = string & { readonly __brand: 'TestRunId' };

type TestRun = {
  id: TestRunId;
  name: string;
  createdAt: Date;
  llm_provider: string;
  llm_model: string;
  metadata: Record<string, any>; // A flexible JSON blob for user metadata.
};
```

**`DataPoint`**
The result of a single LLM call within a `TestRun`.

```typescript
type DataPointId = string & { readonly __brand: 'DataPointId' };

type DataPoint = {
  id: DataPointId;
  final_prompt_text: string;
  response_text: string;
  metrics: Record<string, any>; // JSON blob for latency, token counts, etc.
};
```


---

### Relationship Definitions

These relationships define the connections between entities in the Neo4j graph.

#### Content Structure Relationships

- `(ContentNodeVersion) -[:VERSION_OF]-> (ContentNode)`
  - Links a specific version to its abstract parent node.
- `(ContentNodeVersion) -[:PREVIOUS_VERSION]-> (ContentNodeVersion)`
  - Creates a chronological linked-list of a node's version history.
- `(Parent:ContentNodeVersion) -[:INCLUDES {operation: string, key?: string}]-> (Child:ContentNodeVersion)`
  - Forms the content tree structure. Edge properties define the operation:
    - `operation: 'insert'` - Child provides a value for a placeholder in parent
    - `operation: 'concatenate'` - Child's content is appended to parent
    - `key` - For insert operations, specifies which placeholder to replace
- `(ContentNode) -[:HAS_TAG]-> (Tag)`
  - Applies categorical tags to content nodes for organization and filtering.

#### Test and Result Relationships

- `(TestRun) -[:GENERATED]-> (DataPoint)`
  - Links a test run to the individual data points it produced.
- `(DataPoint) -[:USING_TEST_CASE]-> (TestCase)`
  - Links a result to the test case that defined its conversation structure.
- `(DataPoint) -[:USED_CONTENT]-> (ContentNodeVersion)`
  - Tracks which specific content versions were used in generating the result.

---

### Visual Diagram (Mermaid)

```mermaid
graph TD
    subgraph "Unified Content Tree"
        T(Tag)
        CN(ContentNode) -- name, desc --> CNV(ContentNodeVersion) -- content?, commitMessage
        
        CN -- HAS_TAG --> T
        CNV -- VERSION_OF --> CN
        CNV -- PREVIOUS_VERSION --> CNV
        CNV -- "INCLUDES <br> {operation, key?}" --> CNV
    end

    subgraph "Test Cases & Conversations"
        TC(TestCase) -- name, llmModel --> MS(MessageSlot) -- role, tags, sequence
        TC -- parameters --> PC(ParameterContext)
    end

    subgraph "Experimentation & Results"
        TR(TestRun) -- llm_model, metadata --> DP(DataPoint) -- response, metrics
        TR -- GENERATED --> DP
        DP -- USING_TEST_CASE --> TC
        DP -- USED_CONTENT --> CNV
    end
```

### Key Design Principles

1. **Content is Role-Agnostic**: Content nodes don't specify roles. The same content can serve as system, user, or assistant messages in different test cases.

2. **Tree Structure via Relationships**: The content hierarchy is expressed through Neo4j relationships, not type fields. This leverages the graph database's strengths.

3. **Operations on Edges**: The `INCLUDES` relationship carries operation semantics (insert/concatenate), keeping nodes focused on content.

4. **Lazy Processing**: Content trees are processed on-demand to avoid memory issues with large structures.

5. **Type Safety**: Branded types and Effect schemas ensure compile-time safety and runtime validation.

6. **Flexible Testing**: Test cases enable A/B testing and experimentation without duplicating content.
